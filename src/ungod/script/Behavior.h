/*
* This file is part of the ungod - framework.
* Copyright (C) 2016 Felix Becker - fb132550@uni-greifswald.de
*
* This software is provided 'as-is', without any express or
* implied warranty. In no event will the authors be held
* liable for any damages arising from the use of this software.
*
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute
* it freely, subject to the following restrictions:
*
* 1. The origin of this software must not be misrepresented;
*    you must not claim that you wrote the original software.
*    If you use this software in a product, an acknowledgment
*    in the product documentation would be appreciated but
*    is not required.
*
* 2. Altered source versions must be plainly marked as such,
*    and must not be misrepresented as being the original software.
*
* 3. This notice may not be removed or altered from any
*    source distribution.
*/

#ifndef BEHAVIOR_H
#define BEHAVIOR_H

#include "Script.h"
#include <boost/filesystem.hpp>

namespace ungod
{
    template <typename ... INIT_PARAM> class Behavior;
    template <typename ... INIT_PARAM> class StateBehavior;

    template <typename ... INIT_PARAM> using OptionalBehavior = sol::optional<Behavior<INIT_PARAM...>>;
    template <typename ... INIT_PARAM> using OptionalStateBehavior = sol::optional<StateBehavior<INIT_PARAM...>>;

    template <typename ... INIT_PARAM> using BehaviorPtr = std::shared_ptr<Behavior<INIT_PARAM...>>;
    template <typename ... INIT_PARAM> using StateBehaviorPtr = std::shared_ptr<StateBehavior<INIT_PARAM...>>;

    namespace detail
    {
        using OptionalCallback = sol::optional<sol::protected_function>;
        using OptionalEnvironment = sol::optional<script::Environment>;

        //helper struct to associate a script environment with its name
        struct NamedEnvironment
        {
            script::Environment env;
            std::string name;

            NamedEnvironment(script::Environment e, const std::string& n) : env(e), name(n) {}
        };

        using IdentifierLookup = std::vector< const char* >;

        /** \brief A script meta-object that consists of an environment and an array with cached methods.
        * Is generated by the BehaviorManager per loaded script. */
        class MetaCache
        {
        private:
            OptionalEnvironment mEnvironment;  ///< contains the script-side data
            std::string mName; ///< script-side name of the environment
            std::vector< OptionalCallback > mCallbacks;  ///< maps ids directly to cached methods

            static MetaCache sNullMeta; ///< null object

        public:
            /** \brief Constructs a "null-state" with no method cached. That means, that a call of execute does simply nothing. */
            MetaCache() {}

            /** \brief Initializes the state based on the provided scripted state. */
            MetaCache(NamedEnvironment meta, const IdentifierLookup& callbackIdentifiers);

            /** \brief Initializes the state based on the provided scripted state. */
            void init(NamedEnvironment meta, const IdentifierLookup& callbackIdentifiers);

            /** \brief Executes the callback with given index. Forwards the additional
            * arguments to the method call. */
            template<typename ... ARGS>
            void execute(std::size_t index, ARGS&& ... args) const;

            /** \brief Returns the script-side name of the environment. */
            const std::string& getName() const {return mName;}

            /** \brief Returns true if initialized and safe to use. */
            bool isValid() const { return static_cast<bool>(mEnvironment); }

            /** \brief Returns the environment of the script. Behavior is undefined if the meta cache is not initialized. */
            script::Environment getEnvironment() const { return *mEnvironment; }

            /** \brief Returns the null object. */
            static MetaCache& null() { return sNullMeta; }
        };

        /** \brief Extends the meta cache class with ref-counting of instances so static constr and destr methods can be invoked. */
        class RefMetaCache : public MetaCache
        {
        public:
            RefMetaCache(std::size_t staticConstr, std::size_t staticDestr) : MetaCache(), mStaticConstr(staticConstr), mStaticDestr(staticDestr), mRefCount(0) {}

            /** \brief Refs a new instance. If this is the first instance refered, the static constr method is invoked. */
            template<typename ... PARAM>
            void ref(PARAM&& ... param);

            /** \brief Derefs an instance. If this was the last instance refered, the static destr method is invoked. */
            template<typename ... PARAM>
            void deref(PARAM&& ... param);

        private:
            std::size_t mStaticConstr;
            std::size_t mStaticDestr;
            std::size_t mRefCount;
        };


        /** \brief A object that consist of a ref to script-side instance data. Is coupled to a MetaCache. Is generated
        * per user of a specific script. */
        class InstanceCache
        {
        protected:
            OptionalEnvironment mEnvironment;  ///< refs the script environment, that contains instance data
            MetaCache* mMeta;  ///< the coupled meta cache

            static InstanceCache sNullInstance; ///< null object

        public:
            /** \brief An InstanceCache is always generated by coupling it to a MetaCache. */
            InstanceCache(MetaCache& meta) : mMeta(&meta) {}

            /** \brief Creates a new instance environment in the parent environment. */
            void init(script::Environment parentEnv);

            /** \brief Executes the callback with given index. Forwards the additional
            * arguments to the method call. */
            template<typename ... ARGS>
            void execute(std::size_t index, ARGS&& ... args) const;

            /** \brief Returns the script environment if set. */
            OptionalEnvironment getEnvironment() const;

            /** \brief Returns the script static environment (equal for all instances). */
            script::Environment getStaticEnvironment() const;

            /** \brief Returns the null object. */
            static InstanceCache& null() { return sNullInstance; }
        };


        /** \brief Instance cache with refcount for global state. */
        class RefInstanceCache : public InstanceCache
        {
        public:
            /** \brief An RefInstanceCache is always generated by coupling it to an RefMetaCache. */
            RefInstanceCache(RefMetaCache& meta) : InstanceCache(meta) {}

            /** \brief Forwards the ref vall to the underlying meta cache. */
            template<typename ... PARAM>
            void ref(PARAM&& ... param);

            /** \brief Forwards the deref vall to the underlying meta cache. */
            template<typename ... PARAM>
            void deref(PARAM&& ... param);
        };


        /** \brief Metaobject for Behaviors. Handles the global state. */
        class MetaBehavior
        {
        protected:
            std::string mName; ///< name of the script-file that was loaded to define this behavior
            detail::RefMetaCache mGlobal;  ///< the meta cache for the global behavior

        public:
            MetaBehavior(const std::string& name, std::size_t staticConstr, std::size_t staticDestr)
            : mName(name), mGlobal(staticConstr, staticDestr) {}

            /** \brief Returns a new instance. */
            template <typename ... INIT_PARAM>
            BehaviorPtr<INIT_PARAM...> makeInstance(script::Environment parent, std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param);

            /** \brief Sets up internal cache. */
            void init(NamedEnvironment global, const IdentifierLookup& callbackIdentifiers);

            /** \brief Returns the script static environment (equal for all instances). */
            script::Environment getStaticEnvironment() const;

            /** \brief Returns the script name (which acts as its top level identifier. */
            const std::string& getName() const;
        };


        using StateMap = std::unordered_map< std::string, detail::InstanceCache >;


        /** \brief Metaobject for StateBehaviors. Handles a fixed global state along with a mutable current state. */
        class MetaStateBehavior final : public MetaBehavior
        {
        private:
            StateMap mStatesPrototype; ///< maps identifiers to defined states, acts as a prototype for instances
            std::vector<detail::MetaCache> mStates; ///< stores the metacaches that are references by the prototype instances
            std::string mInitState; ///< the name of the initial state which is the first state defined in the script

        public:
            MetaStateBehavior(const std::string& name, std::size_t staticConstr, std::size_t staticDestr) : MetaBehavior(name, staticConstr, staticDestr) {}

            /** \brief Returns a new instance. */
            template <typename ... INIT_PARAM>
            StateBehaviorPtr<INIT_PARAM...> makeInstance(script::Environment parent, std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param);

            const std::string& getInitState() const { return mInitState; }

            /** \brief Sets up internal caches. */
            void init(NamedEnvironment global, const std::list<NamedEnvironment>& states, const IdentifierLookup& callbackIdentifiers);
            void init(const std::list<NamedEnvironment>& states, const IdentifierLookup& callbackIdentifiers);

            /** \brief Returns the script static environment (equal for all instances). */
            script::Environment getStaticEnvironment() const;
        };

    } //detail

    //////////////////////////////
    //expose high level types
    //////////////////////////////

    template<typename T> using Optional = sol::optional<T>;

    /** \brief A class that models a behavior that can be completely defined in scripts. */
    template <typename ... INIT_PARAM>
    class Behavior
    {
    friend class detail::MetaBehavior;
    protected:
        detail::MetaBehavior* mMeta; ///< the connected meta behavior
        detail::RefInstanceCache mGlobal; ///<fixed global script state
        std::size_t mExitIndex; ///< index of the "state exit" method

    public:
        Behavior(detail::MetaBehavior* meta, const detail::RefInstanceCache& global, std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param);

    public:
        Behavior(const Behavior&) = delete;
        Behavior& operator=(const Behavior&) = delete;

        void init(std::size_t initIndex, INIT_PARAM&& ... param);

        void exit(INIT_PARAM&& ... param);

        /** \brief Executes the callback with given index. Forwards the additional
        * arguments to the method call. */
        template<typename ... ARGS>
        void execute(std::size_t index, ARGS&& ... args) const;

        /** \brief Returns a script variable defined in this behavior. Call is safe. If the variable is not defined, an empty optional is returned. */
        template<typename T, typename KEY>
        Optional<T> getVariable(const KEY& name) const;

        /** \brief Returns a static variable defined in this behavior (equal for all instances. Call is safe. If the variable is not defined, an empty optional is returned. */
        template<typename T, typename KEY>
        Optional<T> getStaticVariable(const KEY& name) const;

        /** \brief Returns the underlying instance environment. */
        detail::OptionalEnvironment getEnvironment() const;

        /** \brief Returns the name of the underlying script, that is its top level identifier. */
        const std::string& getScriptName() const;

        virtual ~Behavior();
    };


    /** \brief A extended behavior that works as a state mashine that handles a
    modificable and a global state concurrently. */
    template <typename ... INIT_PARAM>
    class StateBehavior final : public Behavior<INIT_PARAM...>
    {
    friend class detail::MetaStateBehavior;
    private:
        detail::StateMap mStates; ///< maps identifiers to available states
        detail::InstanceCache* mCurrent; ///< the current state of the script is handled along with the global
        detail::InstanceCache* mLast; ///< caches the state that was active before the current state

    public:
        ///NOTE that since StateBehavior will ALWAYS be initialized with a valid MetaSTATEBehavior ptr, we could safely
        //cast the internal pointer to the MetaBehavior to MetaStateBehavior if needed
        StateBehavior(detail::MetaStateBehavior* meta, const detail::RefInstanceCache& global, detail::StateMap statemap, 
                      std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param);

    private:
        void internalStateChange(detail::InstanceCache* newState, std::size_t initIndex, std::size_t exitIndex, INIT_PARAM&& ... param);

    public:
        StateBehavior(StateBehavior&&) = default;
        StateBehavior(const StateBehavior&) = delete;
        StateBehavior& operator=(const StateBehavior&) = delete;

        void init(std::size_t initIndex, INIT_PARAM&& ... param);

        void exit(INIT_PARAM&& ... param);

        /** \brief Executes the callback with given index. Forwards the additional
        * arguments to the method call. */
        template<typename ... ARGS>
        void execute(std::size_t index, ARGS&& ... args) const;

        /** \brief Changes the current state. Expects indices for state init and exit methods. */
        void changeState(const std::string& newState, std::size_t initIndex, std::size_t exitIndex, INIT_PARAM&& ... param);

        /** \brief Returns to the previous state. */
        void returnToPrevious(std::size_t initIndex, std::size_t exitIndex, INIT_PARAM&& ... param);

        /** \brief Returns a script variable defined in this behavior. Call is safe. If the variable is not defined, an empty optional is returned. */
        template<typename T>
        Optional<T> getStateVariable(const std::string& name) const;

        /** \brief Returns the underlying instance environment for the given state. */
        detail::OptionalEnvironment getEnvironment() const;

        /** \brief Returns the underlying static environment. */
        script::Environment getStaticEnvironment() const;

        virtual ~StateBehavior();
    };

    /** \brief Base of the script manager. Basically wraps a script state. */
    class ScriptStateBase
    {
    public:
        /** \brief Constructor that instantiates a new script state internally. */
        ScriptStateBase();

        /** \brief Constructor that shares access to an existing script state. */
        ScriptStateBase(const script::SharedState& state, script::Environment main);

        /** \brief Registers a new usertype. */
        template<typename CLASS, typename ... ARGS>
        script::Usertype<CLASS> registerUsertype(const std::string& name, ARGS&&... args);

        /** \brief Registers a new enum. */
        template<typename T>
        void registerEnum(const std::string& name, std::initializer_list<std::pair<sol::string_view, T>> items);

        template<typename ... ARGS>
        void registerEnum(const std::string& name, ARGS&&... args);

        /** \brief Registers a new free function. */
        template<typename FUNC>
        void registerFunction(const std::string& name, FUNC&& func);

        /** \brief Creates a new global environment. */
        template<typename ... ARGS>
        script::Environment createEnvironment(ARGS&& ... args);

        /** \brief Access to the underlying script state. It can be shared with other BehaviorManagers. */
        const script::SharedState& getSharedState() const;

        /** \brief Resets the internal script state. */
        void reset();

        /** \brief Resets the internal script state. */
        void reset(const script::SharedState& state, script::Environment main);

        script::Environment getGlobalEnvironment() const { return mMainEnv; }

    protected:
        script::SharedState mScriptState;
        script::Environment mMainEnv;
    };

    enum ScriptErrorCode
    {
        SCRIPT_NOT_FOUND = -3,
        SCRIPT_LOAD_ERROR = -2,
        SCRIPT_EXECUTION_ERROR = -1,
        SCRIPT_OK = 0,
        SCRIPT_ALREADY_LOADED = 1
    };

    /** \brief A manager class to maintain all Behaviors and StateBehaviors. */
    template <typename ... INIT_PARAM>
    class BehaviorManager : public ScriptStateBase
    {
    public:
        /** \brief Constructor that instantiates a new script state internally. */
        BehaviorManager(const detail::IdentifierLookup& identifiers, std::size_t constructIndex, std::size_t initIndex, std::size_t exitIndex, std::size_t staticConstIndex, std::size_t staticDestIndex);

        /** \brief Constructor that shares access to an existing script state. */
        BehaviorManager(const script::SharedState& state, script::Environment main, const detail::IdentifierLookup& identifiers, std::size_t constructIndex, std::size_t initIndex, std::size_t exitIndex, std::size_t staticConstIndex, std::size_t staticDestIndex);

        /** \brief Loads a new behavior script that defines Global- or StateBehavior. */
        ScriptErrorCode loadBehavior(const std::string& filepath);

        void initBehavior(const BehaviorPtr<INIT_PARAM...>& bptr);
        void initBehavior(const StateBehaviorPtr<INIT_PARAM...>& sbptr);

        void exitBehavior(const BehaviorPtr<INIT_PARAM...>& bptr);
        void exitBehavior(const StateBehaviorPtr<INIT_PARAM...>& sbptr);

        /** \brief Creates a new global behavior. This method is exposed to the scripting language. */
        static script::Environment newGlobalBehavior(const std::string& identifier, script::Environment env, sol::optional<detail::NamedEnvironment>& global);

        /** \brief Creates a new state-behavior. This method is exposed to the scripting language. */
        static script::Environment newStateBehavior(const std::string& identifier, script::Environment env, std::list<detail::NamedEnvironment>& states);

        /** \brief Returns a fresh instance of a behavior based on the meta behavior that is stored under the given string.
        * An appropriate meta behavior must be loaded beforehand. The return value follows std::optional semantics and contains a
        * valid result, if and only if the key was found. InstanceEnv must be a valid environment where a subtable for the
        * behavior data can be created. The parent environment must be unique to the instance. */
        BehaviorPtr<INIT_PARAM...> makeBehavior(const std::string& key, script::Environment instanceEnv, bool callConstruct, INIT_PARAM ... param) const;

        /** \brief Returns a fresh instance of a state-behavior based on the meta state-behavior that is stored under the given string.
        * An appropriate meta state-behavior must be loaded beforehand. The return value follows std::optional semantics and contains a
        * valid result, if and only if the key was found. InstanceEnv must be a valid environment where a subtable for the
        * behavior data can be created. The parent environment must be unique to the instance. */
        StateBehaviorPtr<INIT_PARAM...> makeStateBehavior(const std::string& key, script::Environment instanceEnv, bool callConstruct, INIT_PARAM ... param) const;

        /** \brief Accesses a static variable of the given behavior. Call is safe. Returned optional value is empty if not found. */
        template<typename T>
        Optional<T> getStaticVariable(const std::string& key, const std::string& variableName) const;

        /** \brief Returns the static script environment of the given behavior. */
        detail::OptionalEnvironment getStaticEnvironment(const std::string& key) const;

        /** \brief Creates a unique environment for a instance. Id must be unique. */
        script::Environment makeInstanceEnvironment();

        /** \brief Reloads all internal scripts. This will invalidate all behavior and stateBehavior pointers.
        * Returns a list of all reloaded script-files (path-names) along with their corresponding ErrorCodes. */
        std::vector<std::pair<std::string, ScriptErrorCode>> reload();

        /** \brief Reloads all internal scripts. This will invalidate all behavior and stateBehavior pointers.
        * Returns a list of all reloaded script-files (path-names) along with their corresponding ErrorCodes. */
        std::vector<std::pair<std::string, ScriptErrorCode>> reload(const script::SharedState& state, script::Environment main);

    private:
        /** \brief A method to expose several factories to the scripting language that are used to createbehaviors.
        * Is called for the local script environment when the script is loaded. The script may define an optional global behavior and
        * a list of state behaviors. */
        void exposeBehaviorFactories(script::Environment env, sol::optional<detail::NamedEnvironment>& global, std::list<detail::NamedEnvironment>& states);

        /** \brief Removes the script functionality after the script was loaded. */
        void removeBehaviorFactories(script::Environment env);

        /** \brief Loads or reloads a script internally. */
        ScriptErrorCode internalLoad(Script& script, const std::string& filepath);

        /** \brief Implementation of the reload method (avoids code dupliction). */
        std::vector<std::pair<std::string, ScriptErrorCode>> reloadImpl();

        /** \brief Resets all loaded scripts (deref from script state). */
        void resetScripts();

        /** \brief Initializes the internal script state (registers functionality). This
        * is automatically called on construction and on reset. */
        void init();

    private:
        detail::IdentifierLookup mIdentifiers;
        std::unordered_map< std::string, Script > mScripts;
        std::unordered_map< std::string, std::unique_ptr<detail::MetaBehavior> > mBehaviors;
        std::unordered_map< std::string, std::unique_ptr<detail::MetaStateBehavior> > mStateBehaviors;
        std::size_t mConstructIndex;
        std::size_t mInitIndex;
        std::size_t mExitIndex;
        std::size_t mStaticConstIndex;
        std::size_t mStaticDestIndex;
    };

    /** \brief A class that manages a set of callback functions that can be invoked with a specific set of parameters. */
    class CallbackInvoker : public ScriptStateBase
    {
    public:
        /** \brief Creates its own script state. */
        CallbackInvoker(const detail::IdentifierLookup& identifiers);

        /** \brief Shares an existing script state. */
        CallbackInvoker(const script::SharedState& state, script::Environment main, const detail::IdentifierLookup& identifiers);

        /** \brief Loads a script. */
        ScriptErrorCode loadScript(const std::string& filepath);

        /** \brief Executes the method with given index. */
        template<typename ... PARAM>
        void execute(std::size_t id, PARAM&& ... param) const;

        /** \brief Accesses a global variable. */
        script::Environment getEnvironment() const;

        /** \brief Returns true if and only if the invoker is in a valid state. */
        bool isValid() const;

        /** \brief Reloads the internal script.  */
        void reload();

        /** \brief Reloads the internal script.  */
        void reload(const script::SharedState& state, script::Environment main);

    private:
        Script mScript;
        detail::IdentifierLookup mIdentifiers;
        detail::MetaCache mCallbackCache;
    };

    //////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////  IMPLEMENTATION  ////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////

    namespace detail
    {
        template<typename ... ARGS>
        void MetaCache::execute(std::size_t index, ARGS&& ... args) const
        {
            if (index < mCallbacks.size() && mCallbacks[index])
            {
                sol::protected_function func = *mCallbacks[index];
                auto result = func( *mEnvironment, std::forward<ARGS>(args)... );
                if (!result.valid())
                {
                    sol::error err = result;
                    Logger::warning("An error occured during execution of script", mName, "\n", err.what());
                }
            }
        }

        template<typename ... PARAM>
        void RefMetaCache::ref(PARAM&& ... param)
        {
            mRefCount ++;  //increment refcounter and check if static init is needed
            if (mRefCount == 1)
            {
                execute(mStaticConstr, std::forward<PARAM>(param)... );
            }
        }

        template<typename ... PARAM>
        void RefMetaCache::deref(PARAM&& ... param)
        {
            if (mRefCount == 1)
            {
                execute(mStaticDestr, std::forward<PARAM>(param)... );
            }
            mRefCount --;  //increment refcounter and check if static init is needed
        }

        template<typename ... ARGS>
        void InstanceCache::execute(std::size_t index, ARGS&& ... args) const
        {
            if (mEnvironment)
            {
                mMeta->execute(index, *mEnvironment, std::forward<ARGS>(args)...);
            }
        }

        template<typename ... PARAM>
        void RefInstanceCache::ref(PARAM&& ... param)
        {
            //the upcast is safe, since RefInstanceCache are always constructed with RefMetaCaches
            static_cast<RefMetaCache*>(mMeta)->ref(std::forward<PARAM>(param)...);
        }

        template<typename ... PARAM>
        void RefInstanceCache::deref(PARAM&& ... param)
        {
            //the upcast is safe, since RefInstanceCache are always constructed with RefMetaCaches
            static_cast<RefMetaCache*>(mMeta)->deref(std::forward<PARAM>(param)...);
        }

        template <typename ... INIT_PARAM>
        BehaviorPtr<INIT_PARAM...> MetaBehavior::makeInstance(script::Environment parent, std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param)
        {
            RefInstanceCache ic(mGlobal);
            ic.init(parent);
            return std::make_shared<Behavior<INIT_PARAM...>>(this, ic, constructIndex, exitIndex, callConstruct, std::forward<INIT_PARAM>(param)... );
        }

        template <typename ... INIT_PARAM>
        StateBehaviorPtr<INIT_PARAM...> MetaStateBehavior::makeInstance(script::Environment parent, std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param)
        {
            RefInstanceCache iglobal(mGlobal);
            iglobal.init(parent);
            auto statemap = mStatesPrototype;
            for (auto& s : statemap)
            {
                s.second.init(parent);
            }
            StateBehaviorPtr<INIT_PARAM...> sbptr = std::make_shared<StateBehavior<INIT_PARAM...>>(
                        this, iglobal, std::move(statemap), constructIndex, 
                            exitIndex, callConstruct, std::forward<INIT_PARAM>(param)...);
            parent["states"] = sbptr.get();
            return sbptr;
        }
    }


    template <typename ... INIT_PARAM>
    Behavior<INIT_PARAM...>::Behavior(detail::MetaBehavior* meta, const detail::RefInstanceCache& global, std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param)
        : mMeta(meta), mGlobal(global), mExitIndex(exitIndex)
    {
        mGlobal.ref(std::forward<INIT_PARAM>(param)...);
        if (callConstruct)
            mGlobal.execute(constructIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    void Behavior<INIT_PARAM...>::init(std::size_t initIndex, INIT_PARAM&& ... param)
    {
        mGlobal.execute(initIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    void Behavior<INIT_PARAM...>::exit(INIT_PARAM&& ... param)
    {
        mGlobal.execute(mExitIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    Behavior<INIT_PARAM...>::~Behavior()
    {
        mGlobal.deref();
        mGlobal.execute(mExitIndex);
    }

    template <typename ... INIT_PARAM>
    template<typename ... ARGS>
    void Behavior<INIT_PARAM...>::execute(std::size_t index, ARGS&& ... args) const
    {
        mGlobal.execute(index, std::forward<ARGS>(args)...);
    }

    template <typename ... INIT_PARAM>
    template<typename T, typename KEY>
    Optional<T> Behavior<INIT_PARAM...>::getVariable(const KEY& name) const
    {
        if (mGlobal.getEnvironment())
            return mGlobal.getEnvironment()->get<Optional<T>>(name);
        return Optional<T>();
    }

    template <typename ... INIT_PARAM>
    template<typename T, typename KEY>
    Optional<T> Behavior<INIT_PARAM...>::getStaticVariable(const KEY& name) const
    {
        return mGlobal.getStaticEnvironment().get<Optional<T>>(name);
    }

    template <typename ... INIT_PARAM>
    detail::OptionalEnvironment Behavior<INIT_PARAM...>::getEnvironment() const
    {
        return mGlobal.getEnvironment();
    }

    template <typename ... INIT_PARAM>
    const std::string& Behavior<INIT_PARAM...>::getScriptName() const
    {
        return mMeta->getName();
    }


    template <typename ... INIT_PARAM>
    StateBehavior<INIT_PARAM...>::StateBehavior(detail::MetaStateBehavior* meta, const detail::RefInstanceCache& global, detail::StateMap statemap,
                                                std::size_t constructIndex, std::size_t exitIndex, bool callConstruct, INIT_PARAM&& ... param)
        : Behavior<INIT_PARAM...>(meta, global, constructIndex, exitIndex, callConstruct, std::forward<INIT_PARAM>(param)...), mStates(statemap), mCurrent(&detail::InstanceCache::null()), mLast(&detail::InstanceCache::null())
    {
        //call the contruct method for every state
        if (callConstruct)
            for (auto& ic : mStates)
                ic.second.execute(constructIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    void StateBehavior<INIT_PARAM...>::init(std::size_t initIndex, INIT_PARAM&& ... param)
    {
        Behavior<INIT_PARAM...>::init(initIndex, std::forward<INIT_PARAM>(param)...);
        //init the active state
        auto res = mStates.find(static_cast<detail::MetaStateBehavior*>(Behavior<INIT_PARAM...>::mMeta)->getInitState());
        if (res != mStates.end())
        {
            mCurrent = &res->second;
            mCurrent->execute(initIndex, std::forward<INIT_PARAM>(param)...);
        }
    }

    template <typename ... INIT_PARAM>
    void StateBehavior<INIT_PARAM...>::exit(INIT_PARAM&& ... param)
    {
        Behavior<INIT_PARAM...>::exit(std::forward<INIT_PARAM>(param)...);
        mCurrent->execute(Behavior<INIT_PARAM...>::mExitIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    StateBehavior<INIT_PARAM...>::~StateBehavior()
    {
        mCurrent->execute(Behavior<INIT_PARAM...>::mExitIndex);
    }

    template <typename ... INIT_PARAM>
    template<typename ... ARGS>
    void StateBehavior<INIT_PARAM...>::execute(std::size_t index, ARGS&& ... args) const
    {
        Behavior<INIT_PARAM...>::execute(index, std::forward<ARGS>(args)...);
        mCurrent->execute(index, std::forward<ARGS>(args)...);
    }

    template <typename ... INIT_PARAM>
    void StateBehavior<INIT_PARAM...>::internalStateChange(detail::InstanceCache* newState, std::size_t initIndex, std::size_t exitIndex, INIT_PARAM&& ... param)
    {
        mLast = mCurrent;
        mCurrent->execute(exitIndex);
        mCurrent = newState;
        mCurrent->execute(initIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    void StateBehavior<INIT_PARAM...>::changeState(const std::string& newState, std::size_t initIndex, std::size_t exitIndex, INIT_PARAM&& ... param)
    {
        auto state = mStates.find(newState);
        if (state != mStates.end())
        {
            internalStateChange(&state->second, initIndex, exitIndex, std::forward<INIT_PARAM>(param)...);
        }
        else
        {
            Logger::warning("Cant find the requested state", newState, ". Discarding state switch.");
        }
    }

    template <typename ... INIT_PARAM>
    void StateBehavior<INIT_PARAM...>::returnToPrevious(std::size_t initIndex, std::size_t exitIndex, INIT_PARAM&& ... param)
    {
        internalStateChange(mLast, initIndex, exitIndex, std::forward<INIT_PARAM>(param)...);
    }

    template <typename ... INIT_PARAM>
    template<typename T>
    Optional<T> StateBehavior<INIT_PARAM...>::getStateVariable(const std::string& name) const
    {
        if (mStates.size() > 0u)
        {
            if (mStates.begin()->second.getEnvironment())
                return mStates.begin()->second.getEnvironment()->get<Optional<T>>(name);
        }
        return Optional<T>();
    }

    template <typename ... INIT_PARAM>
    detail::OptionalEnvironment StateBehavior<INIT_PARAM...>::getEnvironment() const
    {
        if (mStates.size() > 0u) //todo hacky, but works since every state has the same env... rewrite needed
        {
            return mStates.begin()->second.getEnvironment();
        }
        return detail::OptionalEnvironment();
    }

    template <typename ... INIT_PARAM>
    script::Environment StateBehavior<INIT_PARAM...>::getStaticEnvironment() const
    {
        return mCurrent->getStaticEnvironment();
    }


    template<typename CLASS, typename ... ARGS>
    script::Usertype<CLASS> ScriptStateBase::registerUsertype(const std::string& name, ARGS&&... args)
    {
        return mScriptState->new_usertype<CLASS>(name, std::forward<ARGS>(args)...);
    }

    template<typename T>
    void ScriptStateBase::registerEnum(const std::string& name, std::initializer_list<std::pair<sol::string_view, T>> items)
    {
        mMainEnv.new_enum<T>(name, std::forward<std::initializer_list<std::pair<sol::string_view, T>>>(items));
    }

    template<typename ... ARGS>
    void ScriptStateBase::registerEnum(const std::string& name, ARGS&&... args)
    {
        mMainEnv.new_enum(name, std::forward<ARGS>(args)...);
    }

    template<typename FUNC>
    void ScriptStateBase::registerFunction(const std::string& name, FUNC&& func)
    {
        mMainEnv.set_function(name, func);
    }

    template<typename ... ARGS>
    script::Environment ScriptStateBase::createEnvironment(ARGS&& ... args)
    {
        return mScriptState->create_table_with(std::forward<ARGS>(args)...);
    }


    template <typename ... INIT_PARAM>
    BehaviorManager<INIT_PARAM...>::BehaviorManager(const detail::IdentifierLookup& identifiers, std::size_t constructIndex,
                                                    std::size_t initIndex, std::size_t exitIndex, std::size_t staticConstIndex, std::size_t staticDestIndex)
        : ScriptStateBase(), mIdentifiers(identifiers), mConstructIndex(constructIndex), mInitIndex(initIndex), mExitIndex(exitIndex), mStaticConstIndex(staticConstIndex), mStaticDestIndex(staticDestIndex)
    {
        init();
    }

    template <typename ... INIT_PARAM>
    BehaviorManager<INIT_PARAM...>::BehaviorManager(const script::SharedState& state, script::Environment main, const detail::IdentifierLookup& identifiers,
                                                    std::size_t constructIndex, std::size_t initIndex, std::size_t exitIndex, std::size_t staticConstIndex, std::size_t staticDestIndex)
        : ScriptStateBase(state, main), mIdentifiers(identifiers), mConstructIndex(constructIndex), mInitIndex(initIndex), mExitIndex(exitIndex), mStaticConstIndex(staticConstIndex), mStaticDestIndex(staticDestIndex)
    {
        init();
    }

    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::init()
    {
        mScriptState->new_usertype<StateBehavior<INIT_PARAM...>>("StateBehavior",
                                                                        "switchTo", [this] (StateBehavior<INIT_PARAM...>* states, const std::string& newState, INIT_PARAM... param)
                                                                        {
                                                                            states->changeState(newState, mInitIndex, mExitIndex, std::forward<INIT_PARAM>(param)... );
                                                                        },
                                                                        "returnToPrevious", [this] (StateBehavior<INIT_PARAM...>* states, INIT_PARAM... param)
                                                                        {
                                                                            states->returnToPrevious(mInitIndex, mExitIndex, std::forward<INIT_PARAM>(param)... );
                                                                        } );
    }

    template <typename ... INIT_PARAM>
    ScriptErrorCode BehaviorManager<INIT_PARAM...>::loadBehavior(const std::string& filepath)
    {
        auto emp = mScripts.emplace(filepath, Script());
        if (!emp.second)
            return SCRIPT_ALREADY_LOADED;

        return internalLoad(emp.first->second, filepath);
    }

    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::initBehavior(const BehaviorPtr<INIT_PARAM...>& bptr)
    {
        bptr->init(mInitIndex);
    }

    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::initBehavior(const StateBehaviorPtr<INIT_PARAM...>& sbptr)
    {
        sbptr->init(mInitIndex);
    }

    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::exitBehavior(const BehaviorPtr<INIT_PARAM...>& bptr)
    {
        bptr->exit();
    }

    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::exitBehavior(const StateBehaviorPtr<INIT_PARAM...>& sbptr)
    {
        sbptr->exit();
    }

    template <typename ... INIT_PARAM>
    ScriptErrorCode BehaviorManager<INIT_PARAM...>::internalLoad(Script& script, const std::string& filepath)
    {
        //the optional global behavior and a list of state behaviors may be defined in the script
        sol::optional<detail::NamedEnvironment> global;
        std::list<detail::NamedEnvironment> states;

        //create the script instance and load
        script.load(filepath, script::StateRef(*mScriptState));

        if (!script.isLoaded())
            return SCRIPT_NOT_FOUND;

        if (!script.isValid())
            return SCRIPT_LOAD_ERROR;

        //expose behavior factory methods
        exposeBehaviorFactories( mMainEnv, global, states );

        //run the script that is now able to make use of the factories
        bool exec = script.run();

        //remove the factories to avoid dangling refs to the local vars stored in the lambdas
        removeBehaviorFactories( mMainEnv );

        if (!exec)
            return SCRIPT_EXECUTION_ERROR;

        boost::filesystem::path p = filepath;

        std::string scriptName = p.stem().string();  //name of the script file, used to identifiy the script later on

        if (global)
        {
            if (states.size() == 0)
            {
                auto res = mBehaviors.emplace(scriptName, std::make_unique<detail::MetaBehavior>(scriptName, mStaticConstIndex, mStaticDestIndex));
                if (res.second) //entry is new
                    res.first->second->init( *global, mIdentifiers );
                ungod::Logger::info("Created script", scriptName);
            }
            else
            {
                auto res = mStateBehaviors.emplace(scriptName, std::make_unique<detail::MetaStateBehavior>(scriptName, mStaticConstIndex, mStaticDestIndex));
                if (res.second) //entry is new
                    res.first->second->init( *global, states, mIdentifiers );
                ungod::Logger::info("Created state script", scriptName);
            }
        }
        else if (states.size() > 0)
        {
            auto res = mStateBehaviors.emplace(scriptName, std::make_unique<detail::MetaStateBehavior>(scriptName, mStaticConstIndex, mStaticDestIndex));
            if (res.second) //entry is new
                res.first->second->init( states, mIdentifiers );
            ungod::Logger::info("Created state script", scriptName);
        }

        return SCRIPT_OK;
    }


    template <typename ... INIT_PARAM>
    script::Environment BehaviorManager<INIT_PARAM...>::newGlobalBehavior(const std::string& identifier, script::Environment env, sol::optional<detail::NamedEnvironment>& global)
    {
        if (!global)
        {
            script::Environment loc = env.create_named(identifier);
            global = detail::NamedEnvironment(loc, identifier);
            return loc;
        }
        else
            Logger::warning("Multiple global behaviors defined in a script. The surplus behavior discarded.");
        return global->env;
    }


    template <typename ... INIT_PARAM>
    script::Environment BehaviorManager<INIT_PARAM...>::newStateBehavior(const std::string& identifier, script::Environment env, std::list<detail::NamedEnvironment>& states)
    {
        script::Environment loc = env.create_named(identifier);
        states.emplace_back( loc, identifier );
        return loc;
    }


    template <typename ... INIT_PARAM>
    script::Environment BehaviorManager<INIT_PARAM...>::makeInstanceEnvironment()
    {
        return mMainEnv.create();
    }


    template <typename ... INIT_PARAM>
    BehaviorPtr<INIT_PARAM...> BehaviorManager<INIT_PARAM...>::makeBehavior(const std::string& key, script::Environment instanceEnv, bool callConstruct, INIT_PARAM ... param) const
    {
        auto res = mBehaviors.find(key);
        if (res != mBehaviors.end())
        {
            return res->second->makeInstance(instanceEnv, mConstructIndex, mExitIndex, callConstruct, std::forward<INIT_PARAM>(param)...);
        }
        return BehaviorPtr<INIT_PARAM...>();
    }


    template <typename ... INIT_PARAM>
    StateBehaviorPtr<INIT_PARAM...> BehaviorManager<INIT_PARAM...>::makeStateBehavior(const std::string& key, script::Environment instanceEnv, bool callConstruct, INIT_PARAM ... param) const
    {
        auto res = mStateBehaviors.find(key);
        if (res != mStateBehaviors.end())
        {
            return res->second->makeInstance(instanceEnv, mConstructIndex, mExitIndex, callConstruct, std::forward<INIT_PARAM>(param)...);
        }
        else
            ungod::Logger::error("Can not find a behavior " + key + ". Did you forget to load it?");
        return StateBehaviorPtr<INIT_PARAM...>();
    }


    //TODO: this method is deprecated
    template <typename ... INIT_PARAM>
    template<typename T>
    Optional<T> BehaviorManager<INIT_PARAM...>::getStaticVariable(const std::string& key, const std::string& variableName) const
    {
        //look in the behaviors first...
        auto res = mBehaviors.find(key);
        if (res != mBehaviors.end())
        {
            return res->second->getStaticEnvironment().get<Optional<T>>(variableName);
        }
        //no? maybe in the state behaviors...
        auto res2 = mStateBehaviors.find(key);
        if (res2 != mStateBehaviors.end())
        {
            return res2->second->getStaticEnvironment().get<Optional<T>>(variableName);
        }
        return Optional<T>();
    }

    template <typename ... INIT_PARAM>
    detail::OptionalEnvironment BehaviorManager<INIT_PARAM...>::getStaticEnvironment(const std::string& key) const
    {
        //look in the behaviors first...
        auto res = mBehaviors.find(key);
        if (res != mBehaviors.end())
        {
            return res->second->getStaticEnvironment();
        }
        //no? maybe in the state behaviors...
        auto res2 = mStateBehaviors.find(key);
        if (res2 != mStateBehaviors.end())
        {
            return res2->second->getStaticEnvironment();
        }
        else
            return {};
    }

    template <typename ... INIT_PARAM>
    std::vector<std::pair<std::string, ScriptErrorCode>> BehaviorManager<INIT_PARAM...>::reload()
    {
        BehaviorManager<INIT_PARAM...>::resetScripts();
        ScriptStateBase::reset();
        return reloadImpl();
    }


    template <typename ... INIT_PARAM>
    std::vector<std::pair<std::string, ScriptErrorCode>> BehaviorManager<INIT_PARAM...>::reload(const script::SharedState& state, script::Environment main)
    {
        BehaviorManager<INIT_PARAM...>::resetScripts();
        ScriptStateBase::reset(state, main);
        return reloadImpl();
    }

    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::resetScripts()
    {
        //clear all behaviors
        mBehaviors.clear();
        mStateBehaviors.clear();

        //reset the loaded scripts
        for (auto& s : mScripts)
        {
            s.second.reset();
        }
    }

    template <typename ... INIT_PARAM>
    std::vector<std::pair<std::string, ScriptErrorCode>> BehaviorManager<INIT_PARAM...>::reloadImpl()
    {
        init();

        std::vector<std::pair<std::string, ScriptErrorCode>> res;
        res.reserve(mScripts.size());

        //load the scripts again, this will invalidate all refs assigned to entities
        for (auto& s : mScripts)
        {
            auto err = internalLoad(s.second, s.first);
            res.emplace_back(s.first, err);
        }

        return res;
    }


    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::exposeBehaviorFactories(script::Environment env, sol::optional<detail::NamedEnvironment>& global, std::list<detail::NamedEnvironment>& states)
    {
        //dynamically bind "global" and "env" arguments
        env.set_function("newGlobalBehavior", [&global, env] (const std::string& identifier) -> script::Environment
                         {
                             return BehaviorManager::newGlobalBehavior(identifier, env, global);

                         });
        env.set_function("newStateBehavior", [&states, env] (const std::string& identifier) -> script::Environment
                         {
                             return BehaviorManager::newStateBehavior(identifier, env, states);
                         });
    }


    template <typename ... INIT_PARAM>
    void BehaviorManager<INIT_PARAM...>::removeBehaviorFactories(script::Environment env)
    {
        //remove functions properly to avoid dangling references
        env["newGlobalBehavior"] = sol::nil;
        env["newStateBehavior"] = sol::nil;
    }



    template<typename ... PARAM>
    void CallbackInvoker::execute(std::size_t id, PARAM&& ... param) const
    {
        mCallbackCache.execute(id, std::forward<PARAM>(param)...);
    }
}

#endif // BEHAVIOR_H
